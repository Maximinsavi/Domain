import express from "express";
import multer from "multer";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { GoogleGenerativeAI } from "@google/generative-ai";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const upload = multer({ dest: "uploads/" });

// Initialise Gemini
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Middleware pour le dossier public
app.use(express.static(path.join(__dirname, "public")));
app.use(express.json());

// Route principale pour ta page bots.html
app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "bots.html"));
});

// Route /gemini pour recevoir la requÃªte du formulaire
app.post("/gemini", upload.single("image_file"), async (req, res) => {
  try {
    const { uid, ask, image_url } = req.body;
    const imageFile = req.file;

    // Historique par utilisateur (optionnel)
    const historyPath = path.join(__dirname, "history", `${uid}.json`);
    let history = [];
    if (fs.existsSync(historyPath)) {
      history = JSON.parse(fs.readFileSync(historyPath, "utf8"));
    }

    // Si lâ€™utilisateur tape "clear"
    if (ask.toLowerCase() === "clear") {
      fs.writeFileSync(historyPath, JSON.stringify([]));
      return res.json({ response: "History cleared.", history: [] });
    }

    // PrÃ©parer les entrÃ©es multimodales
    const parts = [];
    if (ask) parts.push({ text: ask });

    if (image_url) {
      parts.push({
        inlineData: {
          mimeType: "image/png",
          data: Buffer.from(await fetch(image_url).then(r => r.arrayBuffer())).toString("base64"),
        },
      });
    } else if (imageFile) {
      const imageData = fs.readFileSync(imageFile.path);
      parts.push({
        inlineData: {
          mimeType: imageFile.mimetype,
          data: imageData.toString("base64"),
        },
      });
      fs.unlinkSync(imageFile.path); // Nettoyer le fichier
    }

    // Envoi Ã  Gemini
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-pro" });
    const chat = model.startChat({
      history: history.map(entry => ({
        role: entry.role,
        parts: entry.parts.map(p => ({ text: p.text })),
      })),
    });

    const result = await chat.sendMessage(parts);
    const responseText = result.response.text();

    // Mettre Ã  jour lâ€™historique
    const newEntries = [
      ...history,
      { role: "user", parts },
      { role: "model", parts: [{ text: responseText }] },
    ];
    fs.mkdirSync(path.join(__dirname, "history"), { recursive: true });
    fs.writeFileSync(historyPath, JSON.stringify(newEntries, null, 2));

    // Retour au front-end
    res.json({
      response: responseText,
      author: "model",
      history: newEntries,
    });
  } catch (error) {
    console.error("Erreur Gemini:", error);
    res.status(500).json({ error: error.message });
  }
});

// DÃ©marrage du serveur
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`ğŸš€ Serveur lancÃ© sur http://localhost:${PORT}`)); 